# module1
yandex practicum module1

1. При развертывании инфраструктуры топики создются автоматически через отдельный контейнер посредством запуска скрипта `./docker/init-kafka/init-kafka-topics.sh`

2. В корне проекта лежит конфигурация сервиса `config.yaml` для локального запуска, `docker.config.yaml` для проброса в docker.

3. При запуске проект читает конфигурацию из файла. Далее инициализирует продьюсер kafka с переданными параметрами конфигурации.
Конфигурация для продьюсера лежит по пути `producer` файла `config.yaml`.

4. Далее происходит инициализация консьюмеров по одному для каждого типа подписчиков, а так же подписка на темы сообщений. Для этого в файле конфигурации отведены секции:
`single_message_consumer` и `batch_message_consumer`.
Секция содержит информацию о количестве получаемых за один запрос к брокеру сообщений. Имя топика (темы) для подписки на получение сообщений, а так же наименование сервиса для отображения в логах.
Дополнительно содаржит конфигурацию для инициализации консьюмера к брокеру.

5. Далее инициализируются сервис отправитель (producer) для генерации сообщений и два сервиса получателя (consumer)

Отправитель генерирует структуру `models.Order` произвольным образом с использованием библиотеки `github.com/brianvoe/gofakeit/v7` и отправляет сообщение в брокер каждые 100ms(параметр конфигурируется в `config.yaml`->`producer`->`produce_timeout`)

Я не стал делить получателя на два типа внутри приложения, а разрулил всё посредством количества получаемых событий. В случае когда количество получаемых сообщений в партии = 1, после получения события мы отправляем его в обработку через обратный вызов функции. 
Когда количество получаемых событий более одного, сервис дожидается указанной партии сообщений или по истечении отведенного времени отправляет партию в обработку.

```services/consumer/service.go
var cFn func() []*kafka.Message
if svc.batchSize > 1 {
	cFn = svc.collectBatch // обработка сообщений пачками
} else {
	cFn = svc.collectImmediate // немедленная обработка каждого сообщения
}
```

из анализа логов можно увидеть как отправляются и получаются события сообщения.
Каждый сервис при логировании собыий обогащен дополнительной мета информацией о имени сервиса: `service: producer`, `service: immediate`, `service: batch_consumer`


6. Для запуска приложения достаточно выполнить команду `docker compose up` и дождаться завершения загрузки контейнеров.
  Для локального запуска приложения закомментировать в docker-compose сервис app, выполнить команду `docker compose up` затем запустить приложение командой `go run main.go`.